# Binary packages vs. Source packages

In general when downloading/installing software on your Linux or Unix-like system, there will be two methods of doing so. You can download the **binaries** for your particular operating system, or you can download the **source code** and compile it yourself. What is the difference between these two approaches? And what does it mean for a package to be a binary package vs. a source package?

## Source packages

Everything we come across in our digital lives is a program (a set of instructions to be run on a computation machine) of one sort or another. Computers only understand 0s and 1s, but humans cannot parse 0s and 1s as efficiently as computers. So we created programming languages to allow us to communicate with computers. Integral to a programming language is its compiler (some languages additionally use an interpreter which we won't get into here, but it's the same *basic* idea even if the details are different). A compiler is itself a program which takes other programs in a designated programming language, and converts it into 0s and 1s so the computer can understand what we're trying to tell it to do.

When you download the source code for a package, you are downloading the actual code which makes up the program. On Windows systems, we practically never see the source code for the programs we are working with. On Linux systems, people wind up working with the source code of the software they are using because there is such a great diversity of configurations of the Linux system. People need the flexibility to tweak things so as to get the software in question working on their system.

When you download the source code for a program, you will generally be downloading some sort of zipped collection of files or a tarball (jargon for describing a bunch of files bundled together in a .tar file). You will then decompress the collection of files and compile the resulting code yourself. This is usually achieved by running `./configure` followed by any specific compile-time options you want to specify, then running `make`, finally finishing with `make install`. `./configure` checks for to make sure all dependencies are installed. `make` runs a series of tasks as defined by the Makefile ([What is a Makefile?](https://www.gnu.org/software/make/manual/make.html)). Most tarballs people download won't have a Makefile. They'll have a templated Makefile called `Makefile.in` which in conjunction with `./configure` will create a custom Makefile for the user's specific system. Finally now that source code has been compiled and built and can be executed, we need to copy it into its final destination on our system which is achieved using `make install`. If you peek into these files, you'll see they are quite dense and many thousands of lines. If you're like me you'll wonder, "How could anybody have wrote all of this?!" Well it turns out people don't write this stuff. It's largely generated from machines. If you're curious, [dig into the details here](https://thoughtbot.com/blog/the-magic-behind-configure-make-make-install).

## Binary packages

Binary packages (called just *binaries*) are source code already built and compiled for you. They are the 0s and 1s a computer can understand. On Windows, practically everything is binaries. Binaries can only be run on the target operating system though (whereas in theory you can run the source code anywhere). This makes sense because if you read the section on [source packages](#source-packages) when one configures the source code, the makefile is going to look different based on the target environment. As a result, if you tried to run a program in Windows built and compiled in Linux you are going to get errors due to the two environment being different (the instructions or 0s and 1s are going to be different). This would be the case for different versions of Linux as well (e.g. Ubuntu vs. Red Hat).

As much as I may have made it seem like source packages are for Linux and binaries are for Windows, that's not really the case. Source packages are useful for people with very niche use cases and as a result need to tweak a lot of the default settings. They're also useful if you need to install the latest version of the software and binaries aren't available yet. Source packages are also necessary in the case binaries aren't available at all (obviously). Most people though do fine with using the binaries usually through using their operating system's package manager (e.g. `apt` and `yum`). Binaries are much easier to download and install (since they've already been compiled which is usually the hardest and longest part). People also generally prefer using binaries provided through their operating system's package manager since the package manager will also handle updating the package for you as well as resolving dependencies. When you download the source package, you have to handle updating and resolving dependencies yourself.

One upside to using source packages is you can inspect the source code of the program. Generally this isn't something people do very often, but if you want to tweak the program or understand how some section of the program is working, it's a useful thing to have. Binaries generally don't have the source code available to be read (unless you're comfortable readings 0s and 1s).

## Links on source vs. binary

[Link to one forum discussion on binaries vs. source](https://stackoverflow.com/questions/5280906/difference-between-binary-release-and-source-release) and [here is another forum discussion](https://askubuntu.com/questions/335684/installation-difference-between-from-source-and-apt-get).
